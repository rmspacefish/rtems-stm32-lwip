RTEMS lwIP STM32 Repository
======

This example was used to test all three major lwIP APIs on the NUCLEO-H743ZI with RTEMS
 
 1. RAW API, high performance using callbacks
 2. Netcon API, sequential API
 3. Socket API, sequential API, less performance but portable API.
 
The APIs were tested using a simple UDP or TCP echoserver. The default port is 7 and DHCP is
enabled by default. The assigned server will be printed so it should be sufficient to plug
the flashed NUCLEO board into a router and monitor the serial output.

After cloning this repository with

```sh
git clone https://github.com/rmspacefish/rtems-stm32-lwip.git
cd rtems-stm32-lwip
```

make sure to clone the submodules as well

```sh
git submodule init
git submodule update
```

# Prerequisites

See [here](https://github.com/rmspacefish/rtems-tools) for a guide to build the RTEMS BSP.
Alternatively, you can download pre-compiled BSPs for Windows from
[here](https://drive.google.com/drive/u/0/folders/15pO3FCUwceghrnYjmNlgC6K1Z8D_6iu2)

# Configuring the application

The application can be configured by using `CMake` build options. You can use `cmake-gui ..` 
or `ccmake ..` to display the options in the build folder. Alternatively, the `conf_app.h` file
can be edited in the build folder manually after it was generated by `CMake`.

# Building the application

It is assumed the RTEMS BSP is installed at the `RTEMS_PREFIX` location. On Windows, it
is recommended to install [MinGW64](https://www.msys2.org/) to have a Unix environment and run the
following command to install `CMake` and required tools.

```sh
pacman -S mingw-w64-x86_64-cmake mingw-w64-x86_64-toolchain
```

To connect to the STM32, make sure to install the `st-link` drivers 
from [here](https://github.com/stlink-org/stlink) as well.

## CMake

Set up the environmental variable `RTEMS_PREFIX` first

```sh
export RTEMS_PREFIX=<RTEMS Prefix Path>
```

You can also extract this step to a script which is `source`ed or add it to the environmental 
variables permanently by adding the line to the `.bashrc` file.

Generate the build system with CMake first:

```sh
mkdir build-Debug && cd build-Debug
cmake -DCMAKE_BUILD_TYPE="Debug" -DRTEMS_BSP="arm/nucleo-h743zi" -DRTEMS_PREFIX=$RTEMS_PREFIX ..
```

You can now edit the `conf_app.h` file inside the build folder to configure the application.

After that, RTEMS lwIP needs to be built and installed. A helper script has been provided to 
do this.

```sh
./install-rtems-lwip.sh
```

Finally, you can build the application

```sh
cd build-Debug
cmake --build . -j
```

## Waf

TODO

# Flashing the application

You can flash the application with Drag & Drop or with OpenOCD. An Eclipse project file is provided
to get started with OpenOCD. You can install OpenOCD for Windows from [here](https://xpack.github.io/openocd/)
with `xpm` to have good Eclipse integration.

When using OpenOCD, it is recommended to perform following steps to avoid the auto-probe error:

Add the following lines to the `stm32h7x.cfg` file located inside the OpenOCD folder inside 
the `scripts/target` folder:

```sh
$_CHIPNAME.cpu0 configure -event gdb-attach {
    halt
}

$_CHIPNAME.cpu0 configure -event gdb-attach {
    reset init
}
```

# Testing the application

The `ip_client` contains a simply Python TCP/IP client implementation which can be
used to test the software.

Alternatively you can use `netcat` to test the application

Send and receive UDP packet:

```sh
echo "Hello from PC" | nc -w1 -u <ipAddress> <port>
```

UDP Client:

```sh
nc -u <ipAddress> <port>
```


# Using Eclipse

To use the given Eclipse project file, copy it from `eclipse` into the root. Then you can 
import the folder as an Eclipse project. Make sure to only import the root project file instead 
of both when importing the project. Right click on the project folder and go to C/C++ Build 
&rarr; Build Variables. Here you can set `RTEMS_PREFIX` accordingly to set up the Eclipse indexer.

